4장. 모던 스프링 부트 웹 시작하기
	1. 간단히 설계하기
		- 마인드맵 기능 설계도 
		- 엔티티 설계 
		- 결과물 출력
	2. 프로젝트 시작하기
		1. Spring Boot Web의 구성
		2. 도메인 맵핑하기
		3. 도메인 테스트하기
		4. 게시글 리스트 기능 만들기
			- pageable

게시글 저장/수정/삭제 기능 만들기(data-rest에서 만들어 보기)
		5. 글 작성 폼 만들기(thymeleaf 템플릿 엔진 사용) - ajax를 사용하여 서버와 비동기 통신

4. Spring Boot web
이제 본격적인 프로젝트를 시작하겠습니다. 
이 장에서 공부해볼 스프링 부트 웹은 스프링 부트 프로젝트에서 가장 기본이 되는 프로젝트입니다. 주로 뷰페이지나 API용도로 사용합니다. API는 나중에 나올 챕터 7에서 Spring Boot Data Rest를 사용하여 개발해 보고 커뮤니티 게시판의 뷰페이지를 만들어 보겠습니다.
사실 스프링 부트 웹을 구성할 수 있는 방법은 다양한 코드와 패턴방식이 있습니다. 그때그때 상황에 따른 최선의 방식으로 구성할 수 있겠지요. 책에는 모든 방식을 담아낼 수는 없었지만 웹에서 쓰이는 기능중 핵심적이면서 스프링에서 제공하는 편리한 라이브러리를 어떻게 사용하는지를 1장에서 얘기했던 커뮤니티 서비스의 게시판을 만들며 살펴볼 것입니다.

이장의 내용
Spring Boot Web 설계하기
Spring Boot Web의 구성
도메인 맵핑하기
도메인 테스트하기
게시글 저장/수정/삭제 기능 만들기
글 작성 폼 만들기
게시글 리스트 기능 만들기

4.1 간단히 설계하기
커뮤니티의 게시판을 어떻게 설계할지 생각해 봅시다. 일단 글을 쓰는 사람과 그 사람이 쓰는 글이 존재하고 글에 대한 여러 기능이 있습니다. 아래 마인드맵에서 이번 설계의 기능들을 확인하실 수 있습니다. 

<그림/>

그림 4-1 마인드맵 기능 설계도
</그림>

간단한 마인드맵이지만 유심히 보시면 의아한 점이 있습니다. 쓰는 사람에 대한 기능이 거의 없는데요 이에 대한 내용은 다음 장 Spring Boot Security에서 진행될 예정이고 이번 장에서는 게시글에 관한 내용위주로만 지행하겠습니다.

어떤 기능을 구성할지 설계했으니 이제는 게시판을 구성하는 객체들이 명확히 나옵니다. 간단하게 글(board), 쓰는 사람(user)이 존재합니다. 이를 도메인으로 표현하면 다음과 같습니다.

<그림/>

그림 4-1 엔티티 관계도
</그림>

2개의 도메인을 생성하였다면 도메인을 DB에 저장하는 역할을 담당하는 repository와 저장하기 전 수행될 로직들을 정의해 주는 service영역을 만들어야 할 것입니다. 마지막으로 저희가 저장한 데이터가 표시될 화면이 있어야 합니다. 

뷰를 구성하는 방법은 여러 서버 사이드 템플릿 엔진을 사용할 수 있습니다. jsp, freemarker, handlebar, thymeleaf 기타 등 어떠한 템플릿 엔진을 사용해도 상관은 없습니다. 다만, 이 책에서는 스프링에서 밀고 있으며 국내에서 대중적인 thymeleaf로 통일할 것입니다.

필자는 글에 관한 서버와의 데이터 전송처리방식을 어떻게 처리해 줄지 고민 하였습니다. 이 책은 스프링 부트에 관련된 책이고 최대한 프론트 스크립트에 대한 내용은 없애려고 하였지만 이번 장이 웹에 대한 프로젝트인 만큼 비동기 통신을 위한 ajax를 최소한으로 사용하고자 합니다.

글에 관한 CRUD를 제공해 주는 API까지 만들면 우리가 생각하는 심플한 게시판이 나올 것입니다.

<그림/>

그림 4-2 게시판 리스트와 작성 폼
</그림>

4.2 프로젝트 시작하기
본격적으로 개발에 들어가겠습니다. Intellij를 사용하여 프로젝트를 생성하도록 하겠습니다. 프로젝트 생성방법은 Spring Boot CLI, Initailizer 등 다양한 방식이 존재합니다. 편리한 방식으로 생성하셔도 무관합니다만 이 책에서는 [챕터 2.1 Intellij IDE 사용하기]의 방식으로 프로젝트 생성이 진행될 것입니다. 프로젝트 이름은 ‘Spring-Boot-Community-Web’으로 라이브러리들은 [그림 4-1]과 같이 체크하여 프로젝트를 생성합니다.

<그림/>

그림 4-3 Web구성에 필요한 의존 라이브러리들
</그림>

4.3 코드 들여다 보기
정상적으로 프로젝트를 생성하였다면 build.script 설정이 [그림 4-2]와 같이 구성되어 있을 것입니다.

<그림/>

그림 4-4 build.script 설정
</그림>

(build.script 각각의 의존성에 대한 설명)
올바르게 생성된 Spring-Boot-Community-Web의 디렉토리 구조는 [그림 4-5]와 같습니다.

<그림/>

그림 4-5 Spring-Boot-Community-Web의 디렉토리 구조
</그림>
4.3.1 Spring Boot Web의 구성
스프링 부트 웹은 웹 구성에 필요한 기본적인 요소들을 담고 있습니다. 아래 스타터의 의존관계 설정을 보시면 어떤 의존성들을 갖고 있는지 전체적으로 확인 가능 합니다. 
물론 세부적으로도 확인 가능하지만 일일이 확인하는 것은 스프링 부트의 취지에도 맞지 않고 생산성 저하로 이어질 수 있기에 큼직하게 보시길 권해드립니다.

<예제/>
예제 4-1 스프링 부트 웹 스타터의 의존설정

<dependencies>
  <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter</artifactId>   ①
  </dependency>
  <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-tomcat</artifactId>   ②
  </dependency>
  <dependency>
     <groupId>org.hibernate</groupId>
     <artifactId>hibernate-validator</artifactId>   ③
  </dependency>
  <dependency>
     <groupId>com.fasterxml.jackson.core</groupId>
     <artifactId>jackson-databind</artifactId>   ④
  </dependency>
  <dependency>
     <groupId>org.springframework</groupId>
     <artifactId>spring-web</artifactId>   ⑤
  </dependency>
  <dependency>
     <groupId>org.springframework</groupId>
     <artifactId>spring-webmvc</artifactId>   ⑥
  </dependency>
</dependencies>
</예제>

① spring-boot-starter : 스프링 부트를 시작하기 위한 기본적인 설정이 담겨있는 스타터(자세한 내용은 [예제 1-2] 참고)
② spring-boot-starter-tomcat : 내장 톰켓을 사용하기 위한 스타터
③ hibernate-validator : 어노테이션 기반의 표준화된 제약조건 및 유효성 검사 규칙을 표현시켜주는 라이브러리
④ jackson-databind : jackson 어노테이션을 사용하여 데이터바인딩, json과 같은 데이터 형식을 파싱 및 생성해 주는 함수 제공
⑤ spring-web : HTTP integration, Servlet filters, Spring HTTP invoker 및 기타 HTTP 코어를 포함시킨 라이브러리
⑥ spring-webmvc : request를 전달하기 위해 dispatcherSevlet 기반으로 MVC(Model-View-Controller)로 디자인된 라이브러리

4.3.2 도메인 맵핑하기
어느정도 프로젝트 환경설정이 끝났습니다. 이제 도메인쪽 맵핑부터 뷰에 데이터를 뿌려주기 까지의 작업을 진행해 보도록 하겠습니다. 사실 프론트(뷰) 부터 먼저 개발하는 순서도 상관은 없습니다. 간단한 기능은 프론트(뷰)나 백엔드(서버)쪽 개발 순서가 상관없지만 점점 더 복잡해질수록 백엔드 개발이 우선시되는 습관을 들이는 것이 좋습니다. 백엔드부터 필요한 데이터에 대한 로직을 먼저 개발한다면 뷰에 사용되는 항목들이 더 명확해 지고 실수할 확률이 줄어들게 됩니다.

도메인 클래스를 생성하여 h2 DB에 맵핑해 봅시다. web 디렉토리 하위에 domain 페키지를 생성하고 설계에서 정의한 도메인 Board, User 클래스를 생성하겠습니다.

(디렉토리 구조 / 도메인 아래 Board, User 생성)

해당 클래스들은 각각 JPA 맵핑을 사용하여 다음과 같이 작성해 줍니다.

<예제/>
@Getter
@NoArgsConstructor
@Entity
@Table
public class Board implements Serializable {

   @Id
   @Column
   @GeneratedValue
   private Long idx;

   @Column
   private String title;

   @Column
   private String subTitle;

   @Column
   private String content;

   @Column
   @Enumerated(EnumType.STRING)
   private BoardType boardType;

   @Column
   private LocalDateTime createdDate;

   @Column
   private LocalDateTime updatedDate;

   @OneToOne(fetch= FetchType.LAZY)
   private User user;

   @Builder
   public Board(String title, String subTitle, String content, BoardType boardType, LocalDateTime createdDate,   LocalDateTime updatedDate, User user) {
       this.title = title;
       this.subTitle = subTitle;
       this.content = content;
       this.boardType = boardType;
       this.createdDate = createdDate;
       this.updatedDate = updatedDate;
       this.user = user;
   }
}
예제 4-1 Board 클래스
</예제>

<예제/>
@Getter
@NoArgsConstructor
@Entity
@Table
public class User implements Serializable {

   @Id
   @Column
   @GeneratedValue
   private Long idx;

   @Column
   private String name;

   @Column
   private String password;

   @Column
   private String email;

   @Column
   private String image;

   @Column
   private LocalDateTime createdDate;

   @Column
   private LocalDateTime updatedDate;

   @Builder
   public User(String name, String password, String email, String image, LocalDateTime createdDate, LocalDateTime updatedDate) {
       this.name = name;
       this.password = password;
       this.email = email;
       this.image = image;
       this.createdDate = createdDate;
       this.updatedDate = updatedDate;
   }
}
예제 4-2 User 클래스
</예제>

(기본 어노테이션에 대한 설명은 이전에 미리했으니 제외한다?, 고민이 필요함)
기본 JPA 어노테이션은 [챕터 3-2]를 참고하시기 바랍니다.
 @Enumerated(EnumType.STRING) : Enum 맵핑을 위한 어노테이션, 현재는 Enum타입을 String형으로 사용하겠다고 선언한 것입니다.
 @OneToOne(fetch= FetchType.LAZY) : 현재 도메인 Board와 필드값으로 갖고 있는 User 도메인을 1:1관계로 설정한다는 어노테이션입니다. fetch는 eager, lazy 두 종류가 있는데 전자는 처음 Board 도메인을 검색해 올 때 즉시 해당 User 객체를 검색해 온다는 뜻이고 후자는 User 객체가 사용될 때 검색해 온다는 뜻입니다.

LocalDateTime은 자바8에 새로 추가된 기능입니다. 기존에는 Date, Calender 등을 주로 사용하였지만 날짜에 대한 연산기능이 많이 부족하였습니다. 때문에 JodaDateTime도 많이 애용되어 왔지만 이제는 자바8부터 내장된 LocalDateTime을 사용하시기를 권해드립니다.
위와 같이 필요한 도메인의 필드들을 생성하였다면 이제는 생성한 도메인이 제대로 동작하는지 테스를 수행해볼 차례입니다.

4.3.3 도메인 테스트하기
도메인 테스트는 스프링 부트에서 지원하는 @DataJpaTest를 사용해 보도록 하겠습니다. @DataJpaTest는 JPA에 대한 테스트를 지원하는 어노테이션으로 테스트 수행된 내용들이 실제 DB에 반영되지 않습니다. 어짜피 저희는 메모리 DB인 h2 DB를 사용하지만 스프링 부트가 제공해 주는 JPA 전영 테스트 어노테이션을 사용해 보도록 합시다.
프로젝트의 test 디렉토리 하위에 JpaMappingTest 클래스를 생성해 보도록 하겠습니다. 생성된 코드는 [예제 4-3]과 같습니다.

<예제/>
@RunWith(SpringRunner.class)
@DataJpaTest
public class JpaMappingTest {

   @Autowired
   UserRepository userRepository;

   @Autowired
   BoardRepository boardRepository;


   @Before
   public void init() {
       User user = userRepository.save(User.builder()
               .name("havi")
               .password("test")
               .email("test@gmail.com")
               .createdDate(LocalDateTime.now())
               .build());

       boardRepository.save(Board.builder()
               .title("테스트")
               .subTitle("서브 타이틀")
               .content("컨텐츠")
               .boardType(BoardType.free)
               .createdDate(LocalDateTime.now())
               .updatedDate(LocalDateTime.now())
               .user(user).build());
   }

   @Test
   public void 제대로_생성_됐는지_테스트() {
       User user = userRepository.findOne(Long.valueOf(1));
       assertThat(user.getName(), is("havi"));
       assertThat(user.getPassword(), is("test"));
       assertThat(user.getEmail(), is("test@gmail.com"));

       Board board = boardRepository.findOne(Long.valueOf(1));
       assertThat(board.getTitle(), is("테스트"));
       assertThat(board.getSubTitle(), is("서브 타이틀"));
       assertThat(board.getContent(), is("컨텐츠"));
       assertThat(board.getBoardType(), is(BoardType.free));
   }

}
예제 4-3 JpaMappingTest 클래스
</예제>

@RunWith(SpringRunner.class) :
@DataJpaTest :
@Before :
@Test :

[예제 4-3]의 코드를 작성하면 에러 메시지가 뜰 것입니다. UserRepository와 BoardRepository를 생성한 적이 없어서 뜨는 메시지인데 해당 클래스들을 생성해 봅시다. Intellij IDE 상에서 Alt+Enter를 누르고 `Make UserRepository`를 선택해 줍니다. com.web 페키지 하위에 repository 디렉토리를 만들고 UserRepository를 생성하여 줍니다. BoardRepository도 똑같이 생성하여 줍니다. 생성된 클래스들에 아래와 같이 코드를 추가해 줍니다. 자세한 내용은 [챕터 3-2]에서 보았던 맵핑 전략를 참고하시기 바랍니다.

<예제/>
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
예제 4-4 UserRepository 클래스
</예제>

<예제/>
@Repository
public interface BoardRepository extends JpaRepository<Board, Long> {
}
예제 4-5 BoardRepository 클래스
</예제>

위와 같이 생성하였다면 더 이상 테스트 코드에 이상은 없을 것입니다. 이제 테스트를 실행한다면 init() 메소드에서 user 테스트 객체를 빌더 패턴을 사용하여 생성한 후 board 객체를 생성할 때 해당 글쓴이로 지정될 user로 넣어줄 것입니다. 여기서 정상적으로 테스트 user 객체와 board 객체가 생성되었다면 제대로_생성_됐는지_테스트() 메소드의 테스트가 ok가 띄워 것입니다. 실제로 테스트를 돌려보면 정상적으로 수행되는 것을 보실 수 있을 것입니다.

(테스트 정상적 수행 메시지)

이제 서비스와 컨트롤러를 생성해 봅시다. com.web.service 하위에 BoardService.java를 생성하겠습니다. 생성된 코드는 다음과 같습니다.

<에제/>
@Service
public class BoardService {

   @Autowired
   BoardRepository boardRepository;

   public Page<Board> findBoardList(Pageable pageable) {
       pageable = new PageRequest(pageable.getPageNumber() <= 0 ? 0 : pageable.getPageNumber() - 1, pageable.getPageSize());
       Page<Board> boardPage = boardRepository.findAll(pageable);
       return new PageImpl<>(boardPage.getContent(), pageable, boardPage.getTotalElements());
   }

   public Board findBoardByIdx(Long idx) {
       return boardRepository.findOne(idx);
   }

   public Board saveAndUpdateBoard(Board board) {
       return boardRepository.save(board);
   }
}
예제 4-6 BoardService 클래스
</예제>

(BoardService에 대한 설명)

com.web.controller 하위에 BoardController.java를 생성하겠습니다. 생성된 코드는 다음과 같습니다.

<예제/>
@Controller
@RequestMapping("board")
public class BoardController {

   @Autowired
   BoardService boardService;

   @GetMapping("/{idx}")
   public String board(@PathVariable Long idx, Model model) {
       model.addAttribute("board", boardService.findBoardByIdx(idx));
       return "/board/form";
   }

   @GetMapping("/list")
   public String list(@PageableDefault Pageable pageable, Model model) {
       model.addAttribute("boardList", boardService.findBoardList(pageable));
       return "/board/list";
   }
}
예제 4-7 BoardController 클래스
</예제>

(BoardController에 대한 설명)

(@저장하는 부분 부터 만들기)

4.3.4 게시글 저장/수정/삭제 기능 만들기
h2 DB에 도메인이 맵핑되기까지의 과정을 성공적으로 수행하였습니다. 그럼 실제로 게시글 저장/수정/삭제하는 기능을 만들어 봅시다.
저희가 위에서 만들어 놓았던 BoardRepository를 사용한다면 별도의 구성없이 바로 원하는 기능을 구현할 수 있습니다. 그럼 Repository를 거치기 전 비즈니스 로직을 담을 BoardService에 다음 코드를 추가시킵니다.
(BoardService 코드)
(세부적인 코드 부연 설명)
단순히 BoardRepository에서 save, delete를 수행하는 기능의 통로 정도로 보실수도 있습니다. 하지만 그 이전에 서비스는 비즈니스 로직을 수행하기 위한 역할을 수행합니다.
실제로 저희 코드는 단순하지만 실제 서비스에서 개발을 한다면 상당한 양의 비즈니스 로직이 들어갈 것입니다. 
서비스를 완성하셨다면 이제 뷰와 연결해줄 컨트롤러를 만들어 봅시다. 컨트롤러는 아래와 같은 코드로 작성합니다.
(BoardController 코드)
(세부적인 코드 부연 설명)
컨트롤러는 Restful하게 저장기능은 PUT, 수정기능은 POST, 삭제기능은 DELETE로 받을 수 있도록 작성하겠습니다. Restful 방식은 API를 구성할때도 동일한 형식으로 구성됩니다.

4.3.5 글 작성 폼 만들기
게시판의 기본적인 서버 동작 기능들이 완성되었습니다. 이제 브라우저에서 렌더링하고 기능들을 쓸 수 있도록 thymeleaf 뷰 템플릿을 사용할 것입니다. 의존성은 처음 설정부터 받아왔기 때문에 templates 디렉토리 하위에 템플릿을 생성하여 바로
작성을 수행하면 됩니다. templates 하위에 board/form.html을 만들도록 하겠습니다.
(디렉토리 구조 그림)
(form.html 그림)
(코드 설명 - th, css, image, 데이터 바인딩)

형식은 완성하였지만 저장, 수정, 삭제에 대한 기능은 서버와의 통신이 필요하기 때문에 HTML의 form이나 ajax를 사용해야 합니다. 책이 스프링 부트에 관련된 책이지만 프론트와 백엔드의 통신을 위해 간단하게 ajax를 사용해 보도록 하겠습니다.
일단 ajax 코드를 추가하고 설명을 이어가겠습니다.
(ajax 코드 추가)
(ajax 설명)

스프링 부트를 구동하여 http://localhost:8080/board/form으로 들어가서 실제 동작되는지 확인해 보겠습니다.
(정상적 동작 화면 제공)


h2 데이터베이스의 콘솔창을 활용하기 위해 build.script에서 `complieOnly`를 `complie`로 변경시켜줍니다. 


