# 리눅스 부하 파해치기
부하를 안다는 것은 OS의 상태를 알고 진단한다는 것을 의미한다.
멀티태스킹의 동작원리는 프로세스의 상태와 부하의 관계를 의미
애플리케이션에서 부하분산은 대체적으로 디스크 I/O를 분산, 경감시키는 작업
OS에는 I/O를 줄이기 위해 캐시 매커니즘이 있다. 캐시가 가장 효율적으로 동작할 수 있도록 시스템을 구성시키는게 목표
모든 부하에 대한 정보는 리눅스 커널이 지니고 있다. 즉, 커널을 알면 부하를 안다.

## 일반적인 부하 파악 순서 

### 1. Load Average 확인
top, uptime등의 명령어로 LA를 확인한다. LA는 부하의 지표만을 제공할 뿐 원인을 찾아주지는 않는다.

### 2. CPU, I/O 중 원인 조사
sar, vmstat 등의 명령어로 CPU사용률이나 I/O대기율의 추이를 확인하며 규명한다.

#### CPU 부하가 높은 경우
- 사용자 프로그램 병목인지, 시스템 프로그램이 원인인지 확인한다.
- ps로 프로세스의 상태나 CPU 사용시간 등을 보며 원인 분석
- 프로세스를 찾은 후 상세한 조사는 strace로 추적하거나 oprofile로 프로파일링해서 병목지점을 좁혀간다.

#### I/O 부하가 높은 경우 
- 프로그램의 입출력이 많아서, 스왑이 발생해서 디스크 액세스가 발생하고 있는 경우가 대부분이다.
- sar, vmstat으로 문제상황 파악

## 부하란?
크게 두 가지로 분류
- CPU 부하
- I/O 부하

![task-1](https://user-images.githubusercontent.com/15729299/56255797-24b1bb80-6101-11e9-9860-4052bf00f223.png)

하나의 CPU가 실행할 태스크가 늘어다면 점점 대기하는 태스크가 늘어나게 된다. 이러한 대기 상태는 실행지연으로 나타난다. LA를 top으로 알아보면 다음과 같이 찍힌다.
```text
load average : 0.54, 0.44, 0.34
```
왼쪽부터 1분, 5분, 15분 동안 단뒤시간당 대기된 태스크 수를 나타낸다. **즉, LA가 높으면 지연되는 태스크 수가 많다는 것을 의미한다.**
위의 그림에서 프로세스 스케줄러는 태스크의 대기를 제어하는 프로그램이다. 스캐줄러를 살펴보면 부하의 정체에 대해 파악할 수 있다.

### 프로세스 스케줄링과 프로세스 상태
프로세스는 프로그램의 실행단위이다. 대체적으로 태스크와 비슷한 의미이다. 예를 들어, 
1. ls 명령 실행
2. 바이너리 파일에서 기계어 명령이 메모리로 전달 
3. CPU가 메모리에서 명령을 꺼내어(Fetch) 실행
4. 명령 실행시 ls 명령이 필요한 여러 메모리 영역 주소, 실행중인 명령 위치, 오픈한 파일 목록 등 다양한 정보가 필요

위의 순서데로 동작하는데 여기서 알 수 있는 것은 프로세스란 `프로그램의 명령`과 `실행시에 필요한 정보`가 한 덩어리로 된 오브젝트를 말한다.

#### 프로세스 디스크립터
리눅스 커널의 프로세스마다 생성되는 관리용 테이블이다. 여기에는 각종 실행 정보가 저장된다.

상태 | 설명
-- | --
TASK_RUNNING | 실행가능 상태
TASK_INTERRUPTIBLE | 중단 가능한 대기상태
TASK_UNINTERRUPTIBLE | 중단 불가능한 대기상태
TASK_STOPPED | 중지 시그널을 받아서 실행 중단된 상태
TASK_ZOMBIE | 자식 프로세스가 exit해서 부모 프로세스로 반환될 때까지의 상태

![task_2](https://user-images.githubusercontent.com/15729299/56255806-3004e700-6101-11e9-9b1b-e3d52e463098.jpg)

#### 프로세스 스케줄러
프로세스 디스크립터군을 우선도가 높은 순으로 지배열하여 실행순서를 조정하는 것은 프로세스 스케줄러라 한다. 

### Load Average로 환산되는 상태
LA는 `대기 태스크의 평균수`를 나타내는 수치였다. 즉, LA로 환산되는 것은 TASK_RUNNING, TASK_UNINTERRUPTIBLE이다.
- CPU를 사용하고 싶어도 다른 프로세스가 사용하고 있어 기다리고 있는 프로세스
- 계속해서 처리고하자 해도 디스크 입출력이 끝날 때까지 기다려야 하는 프로세스
>위에 대한 코드는 kernel/timer.c의 nr_active 메서드에서 확인 가능 

보다 구체적으로 LA가 의미하는 부하는 다음과 같다.
- CPU의 샐행권한이 부여되기를 기다리는 프로세스
- 디스크 I/O가 완료하기를 기다리는 프로세스

### TASK 상태는 어떻게 확인하나?
```markdown
[dd:~]$ ps auxw | egrep "(STAT|httpd)"
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
www      131581  0.0  0.0 112716   980 pts/0    S+   11:03   0:00 grep -E --color=auto (STAT|httpd)
```
STAT열에서 확인 가능하다
- R(Run): TASK_RUNNING
- S(Sleep): TASK_INTERRUPTIBLE
- D(Disk Sleep): TASK_UNINTERRUPTIBLE
- Z(Zombie): TASK_ZOMBIE

## VSZ, RSS(가상 메모리와 물리 메모리)
VSZ(Virtual Set Size)는 프로세스가 확보한 가상 메모리의 크기, RSS(Resident Set Size)는 물리 메모리 크기를 말한다.
가상 메모리란 프로그램이 직접 물리 메모리를 다루지 않고 가상 메모리를 추상화한 소프트웨어적 메모리를 다루는 구조다. 프로세스가 메모리를 필요로 할때 커널은 실제 물리 메모리 주소를 넘기는 것이 아니라 가상 메모리 주소를 넘긴다.
프로세스는 가상 메모리를 실제 메모리로 간주하고 처리한다. 프로세스가 실제로 새로운 가상 메모리 영역에 대해 쓰기작업을 수행하는 시점에 물리 메모리와 연결관계를 맺는다.
![1](https://user-images.githubusercontent.com/15729299/56277393-3914a900-613f-11e9-8e4b-33f9d8d2619e.jpg)

### 가상 메모리 혜택
- 물리 메모리의 원래 용량의 이상을 다룰 수 있는 것처럼 프로세스에게 보일 수 있다.
- 물리 메로리에 흩어져 있는 영역을 하나의 연속된 영역처럼 보이게 한다.
- 물리 메모리에 공간이 부족할 때 2차 기억장치(디스크)에 저장해두고 다시 필요해 지면 원래데로 되돌린다.(스왑)
