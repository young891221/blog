### 3.5 템플릿과 콜백

#### 템플릿/콜백의 동작원리
> **템플릿**: 어떤 목적을 위해 미리 만들어둔 모양이나 틀을 가리킨다. JSP는 HTML이라는 고정된 부분에 EL과 스크립릿이라는 변하는 부분을 넣은 일종의 템플릿 파일이다.
**콜백**: 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말한다. 자바에선 메소드 자체를 파라미터로 전달할 방법이 없기 때문에 메소드가 담긴 오브젝트를 전달한다. 이것을 functional object라 한다.

- UserDao와 StatementStrategy, JdbcContext를 이용한 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식을 템플릿/콜백 패턴이라 한다.
- 전략 패턴의 컨텍스트를 템플릿이라 부르고, 익명 내부 클래스를 콜백이라 부른다.
- 템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다. 템플릿은 특정 기능을 위해 한 번만 노출되는 것이 일반적이기 때문이다.
- 클라이언트가 템플릿 메소드를 호출하면서 콜백 오브젝트를 전달하는 것은 메소드 레벨의 DI이다.
- DI작업이 클라이언트가 템플릿의 기능을 호출하는 것과 동시에 일어난다.
- DI는 사용할 의존 오브젝트를 수정자 메소드로 받는 반면, 템플릿/콜백 방식은 매번 메소드 단위로 사용할 오브젝트를 전달받는 것이 특징이다.
- 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다는 것도 특징이다.

<p align="center">
<img src="/images/Tobi/3.8.png"/>
</p>

- 클라이언트
	- 1)템플릿 안에서 실행될 로직을 담은 콜백 오브젝트 만들고, 콜백이 참조할 정보를 제공하는 것
	- 2)만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달
- 템플릿
	- 3)정해진 작업 흐름을 따라 작업 진행
	- 4)내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드 호출
	- 5)콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해 작업을 수행하고 결과를 다시 템플릿에 반환
	- 6)템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마무리. 경우에 따라 최종 결과를 클라이언트에 반환

#### 콜백의 분리와 재활용
이번에는 익명 내부 클래스 코드를 분리해 보는 작업을 해보자. 변하는 부분과 변하지 않는 부분을 구분하여 리펙토링 해보자.
```java
public void deleteAll() throws SQLException {
    executeSql("delete from users"); //변하는 sql 문장
    
}

private void excuteSql(final String query) throws SQLException {
    this.jdbcContext.workWithStatementStrategy(
    	new StatementStrategy() { //변하지 않는 콜백 클래스 정의와 오브젝트 생성
    	    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    	        return c.prepareStatement(query);
    	    	}
    	}
    );
}
```
한 단계 더 나아가 보자. excuteSql의 성격상 userDao에서만 사용하는 것이 아니라 이렇게 재사용 가능한 콜백 메소드는 DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨도 된다. 엄밀히 말하면 템플릿은 JdbcContext 클래스가 아니라 workWithStatementStrategy() 메소드이므로 
JdbcContext 클래스로 excuteSql() 메소드를 옮겨도 문제 될건 없다.
```java
public class JdbcContext {
    ...
    public void excuteSql(final String query) throws SQLException {
        this.jdbcContext.workWithStatementStrategy(
        	new StatementStrategy() {
        	    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
        	        return c.prepareStatement(query);
        	    	}
        	}
        );
    }
}
```
```java
public void deleteAll() throws SQLException {
    this.jdbcContext.excuteSql("delete from users");
}
```
- deleteAll에서 jdbcContext의 excuteSql()을 호출해서 사용하는 구조가 되었다.
- 결국 JdbcContext 안에 클라이언트와 템플릿, 콜백이 모두 공존하여 동작하는 구조가 됐다.
	- 일반적으로 성격이 다른 코드들은 가능한 분리하는게 좋지만, 이 경우에는 하나의 목적을 위해 긴밀하게 연관되며 응집력이 강한 코드는 모여 있는 것이 유리하다.
	- 구체적인 구현과 내부의 전략 패턴, DI, 익명 내부 클래스 등으로 기술은 최대한 감추고, 꼭 필요한 기능을 제공하는 단순한 메소드만 외부에 노출해 주는 것이다.
 
