# AOP
AOP는 IOC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술의 하나이다. 이 장에서는 AOP의 등장배경, 도입 이유, 장점이 무엇인지 살펴본다.

### 6.1 트랜잭션 코드의 분리
비즈니스 로직과 트랜잭션 경계설정의 분리를 통해 성격이 다른 코드를 각각 독릭적인 코드로 만들 수 있다. 
```java
public void upgradeLevels() throws Exception {
    TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
    try {
        upgradeLevelsInternal();
        this.transactionManager.commit(status);
    } catch (Exception e) {
        this.transactionManager.rollback(status);
        throw e;
    }
}

private void upgradeLevelsInternal() { //비즈니스 로직 분리
    List<User> users = userDao.getAll();
    for(User user : users) {
        if(canUpgradeLevel(user)) {
            upgradeLevel(user);
        }
    }
}
```

### DI 적용을 이용한 트랜잭션 분리
위의 코드에서 트랜잭션이 처리되는 부분을 아에 코드상에서 제거할 수는 없을까? 다음과 같이 UserService를 구현하면서 비즈니스 로직과 트랜잭션 처리 부분이 분리된 코드를 생각해 볼 수 있다. 

<p align="center">
<img src="/images/Tobi/6.3.png"/>
</p>

코드로 구현하면 다음과 같다.
```java
public interface UserService {
    void add(User user);
    void upgradeLevels();
}
```
```java
public class UserServiceImpl implements UserService {
    UserDao userDao;
    MailSender mailSender;
    
    public void upgradeLevels() {
        List<User> users = userDao.getAll();
        for(User user : users) {
            if(canUpgradeLevel(user)) {
                upgradeLevel(user);
            }
        }
    }
    
    ...
}
```
```java
public class UserServiceTx implements UserService {
    UserService userService;
    PlatformTransactionManager transactionManager;
    
    public void serTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
    
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    
    public void add(User user) {
        this.userService.add(user);
    }
    
    public void upgradeLevels() {
        TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            userService.upgradeLevels();
            this.transactionManager.commit(status);
        } catch (RuntimeException e) {
            this.transactionManager.rollback(status);
            throw e;
        }
    }
}
```
- 추상화된 트랜잭션 구현 오브젝트를 DI 받을 수 있도록 PlatformTransactionManager 타입의 프로퍼티도 추가되었다.
- 이전과 동일한 기능을 수행하지만 비즈니스 로직과 트랜잭션 처리 부분이 완전히 분리되어 추상화되었다.

### 트랜잭션 분리에 따른 테스트 수정
- @Autowired로 UserService를 가져오면 UserService가 인터페이스더라도 기본적으로 아무런 문제가 없다.
- 하지만 구현 클래스가 두 개라면 기본적으로 타입을 이용해 빈을 찾미낭 하나의 빈을 결정할 수 없는 경우에는 필드 이름을 이용하여 찾는다.
- 하지만 테스트에서는 MailSender라는 빈을 하나 더 가져와야 한다.
- 이 때에는 목 오브젝트를 이용해 수동 DI를 적용하는 테스트이기에 어떠한 오브젝트인지 분명하게 선언하는게 좋다.
```java
@Test
public void upgradeLevels() throws Exception {
    ...
    MockMailSender mockMailSender = new MockMailSender();
    userServiceImpl.setMailSender(mockMailSencder);
}

@Test
public void upgradeAllorNothing() throws Exception {
    TestUserService testUserService = new TestUserService(users.get(3).getId());
    testUserService.setUserDao(userDao);
    testUserService.setMailSender(mailSender);
    
    UserServiceTx txUserService = new UserServiceTx();
    txUserService.setTransactionManager(transactionManager);
    txUserService.setUserService(testUserSerivce);
    
    userDao.deleteAll();
    for(User user : users) userDao.add(user);
    
    try {
        txUserService.upgradeLevels();
        fail("TestUserServiceException expected");
    }
}

static class TestUserService extends UserServiceImpl { ... }
```
- 트랜잭션 주입을 위해 UserServiceTx 오브젝트를 수동 DI 시킨 후에 트랜잭션 기능까지 포함해서 테스트를 진행한다.
- TestUserService 클래스는 이제 UserServiceImpl 클래스를 상속하도록 바꿔주면 된다.

> **트랜잭션 경계설정 코드 분리의 장점**: 첫 번째는 이제 비느지스 로직을 수정할 때는 트랜잭션과 같은 기술적인 내용은 전혀 신경쓰지 않아도 된다. 두 번째는 이를 통해 비느지스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

