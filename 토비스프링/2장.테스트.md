# 테스트
스프링의 가장 중요한 가치를 무엇이냐고 질문한다면 그 가치는 객체지향과 테스트에 있다. 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IOC/DI 같은 기술이라면, 만들어진 코드에 확신을 주고 변화에 유연하게 대처할 수 있는 자신감을 
주는 테스트 기술이 있다. 2장에서는 테스트란 무엇이며, 그 가치와 장점, 활용 전략, 스프링과의 관계를 살펴본다.

### 2.1 UserDaoTest 다시 보기
- 이전에는 main() 메소드를 이용해 UserDao 오브젝트의 함수를 호출하고 결과물을 출력함으로써 테스트를 수행하였다.
- 테스트란 결국 내가 예상했던 데로 코드가 정확히 동작하는지 확인해서, 내 코드에 대한 확신을 갖게 해주는 작업이다.
- 테스트에서 원치 않는 결함이 나오면 이를 제거해가는 작업, 일명 디버깅을 거치게 되고, 이를 통해 결함이 없는 코드를 만들어 나가는게 테스트이다.

#### 웹을 통한 DAO 테스트 방법의 문제점
보통의 웹 프로그래밍에서 DAO를 테스트하는 방법은 다음과 같다.
- DAO를 만든 뒤 바로 테스트하지 않고, 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 만든다.
- 이렇게 만들어진 웹 애플리케이션을 서버에 배치한 뒤 웹 화면을 띄우고, 값을 직접 입력하며 테스트를 진행한다.
- 이상이 없으면 입력한 값을 화면에 출력해 주는 기능을 만들어서 또 다른 기능까지 확인해 본다.
`이런식의 테스트는 DAO, 서비스, 컨트롤러, 뷰 등 모든 레이어 기능을 다 만들고 나서야 테스트가 가능하다는게 가장 큰 문제이다.` 테스트를 하는 중에 에러가 나거나 과연 어디에서 문제가 일어났는지에 대한 수고도 필요하다. 단순히 에러 메시지와 호출 스택 정보만 
보고 간단히 원인을 찾을 수 없는 문제가 비일비재하다. 그렇다면 테스트를 어떻게 해야 효율적일수 있을까?

#### 작은 단위의 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.
- UserDaoTest는 한 가지 관심에만 집중할 수 있게 작은 단위로 만들어진 테스트이다.
- 다른 작업 필요없이 간단하게 IDE나 도스창에서 테스트 수행이 가능하다.
- 엉뚱하게 JSP나 서블릿에서 에러가 발행해서 그것을 찾으려 시간낭비할 필요가 없다.
`이렇게 작은 단위로 테스트를 수행하는 것을 단위 **테스트**라 한다.`
- 여기서 말하는 단위는 크게 보자면 관리 기능을 모두 통틀어 하나의 단위로 볼 수도 있고, 작게 보자면 UserDao의 add()메소드 하나만을 단위라 생각할 수도 있다.
- 처음부터 긴 테스트를 한번에 수행하면 디버깅하는데 시간이 오래 걸릴수도 있고, 기능은 잘 잘동하지만 원치 않는 값일수도 있는 여러 이슈가 있다.
- 하지만, 작은 단위의 테스트를 수행하고 긴 테스트를 한다면 테스트 실패율이 줄어든고 디버깅 또한 훨씬 수월할 것이다.

#### UserDaoTest 문제점
- 수동 확인 작업의 번거로움
	- UserDaoTest는 수행과정과 입력 데이터의 준비를 모두 자동으로 진행하도록 만들어졌다.
	- 모든 결과는 콘솔에 출력하는데, 결국 콘솔에 나온 결과를 확인하는 건 사람의 책임이다.
	- 테스트 수행은 자동으로 진행되지만 결과를 확인하는 책임은 완전히 자동으로 테스트한다 할 수 없다.
- 실행 작업의 번거로움
	- 아무리 간단히 실행 가능한 main() 메소드라고 해도 DAO에 대한 작업이 확장되어 그것을 수백개 만들고 수백번 돌리는 것은 그만큼 수고스럽다.
	- 그래서 main()메소드보다 좀 더 편리하고 체계적으로 테스트하여 결과를 확인하는 방법이 필요하다.

### 2.2 UserDaoTest 개선
자동화 테스트를 위한 xUnit 프레임워크를 만든 켄트 백은 "테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것"이라고 했다. 개발을 완료했는데 기존 기능에 문제가 있지는 않을지, 새로운 기능을 추가했는데 회사에서 당장 문제를 해결하라 전화했을 때 등 
우리는 다양한 문제에 직면하게 된다. 하지만 자동화된 코드로 테스트를 수행함으로써 이러한 문제들에 대해 조기에 대처할 수 있다. 
우리가 수행한 단순한 main() 메소드로는 애플리케이션이 확장될 수록 테스트를 감당하는데에 한계가 있다. 이를 위해 좋은 테스팅 프레임워크인 JUnit이 존재한다.
- 우리가 배웠던 제어의 역전(IOC)의 원리에 따라 프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아 애플리케이션의 흐름을 제어한다.
- 따라서 기존에 만들었던 main()은 제어권을 직접 갖고 있다. 그래서 우리는 테스트 코드를 일반 메소드로 옮겨야 한다.
- JUnit이 요구하는 조건은 다음 두 가지가 있다.
	- 메소드를 public으로 선언해야 한다.
	- @Test라는 애노테이션을 붙여야 한다.
```java
import org.junit.Test;
...

public class UserDaoTest {
    @Test
    public void addAndGet() throws SQLException {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicaionContext.xml");
        UserDao dao = context.getBean("userDao", UserDao.class);
        ...
    }
}
```
- main 메소드를 대신하여 일반 메소드에 적절한 이름을 붙여주며 테스트의 의도를 나타내는 이름이 좋다.
- 접근지정자를 public으로 주는것을 잊으면 안된다.

#### 검증 코드 전환
자바코드로 검증을 구하는 조건을 표현하면 다음과 같다.
```java
//user 오브젝트의 name 값과 user2 오브젝트의 name 값이 같으면 다음으로 넘어가고 아니면 테스트 실패
if(!user.getName().equals(user2.getName())) {...}
```
위의 문장을 JUnit에서 제공해주는 assertThat이라는 스태틱 메소드를 이용하면 다음과 같다.
```java
assertThat(user2.getName(), is(user.getName()));
```
- assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매치(matcher)라고 블리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트 실패를 뱉어낸다.
- is()는 매처의 일종으로 equals()로 비교해주는 기능을 가졌다.
- JUnit은 다양한 방법으로 테스트 결과를 알려주므로 굳이 수동으로 "테스트 성공"이라는 메시지를 출력할 필요가 없다.
최종코드는 다음과 같다.
```java
import org.junit.Test;
import static org.junit.Assert.asserThat;
...

public class UserDaoTest {
    @Test
    public void addAndGet() throws SQLException {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicaionContext.xml");
        
        UserDao dao = context.getBean("userDao", UserDao.class);
        User user = new User();
        user.setId("kim");
        user.setName("김영재");
        user.setPassword("spring");
        dao.add(user);
        
        User user2 = dao.get(user.getId());
        
        assertThat(user2.getName(), is(user.getName()));
        assertThat(user2.getPassword(), is(user.getPassword()));
    }
}
```

#### JUnit 테스트 실행
간단하게 클래스안에 main() 메소드를 하나 추가하고, @Test 테스트 메소드를 가진 클래스의 이름을 넣어준다.
```java
import org.junit.runner.JUnitCore;
...
public static void main(String[] args) {
    JUnitCore.main("spring.user.dao.UserDaoTest");
}
```

### 2.3 개발자를 위한 테스팅 프레임워크 JUnit
가장 좋은 JUnit 실행방법은 IDE에 내장된 JUnit 테스트 지원도구를 사용하는 것이다. @Test가 들어 있는 테스트 클래스 선택 후 RUN AS 항목 중에서 JUnit Test를 선택하면 테스트가 자동으로 실행된다. JUnitCore를 사용할 때처럼 main() 메소드를 만들지 않아도 된다. 
최종결과는 테스트의 총 수행시간, 실행한 테스트의 수, 테스트 에러의 수, 테스트 실패의 수를 확인할 수 있다. 또한, 실패한 이유는 뷰의 아래 Failure Trace 항목에 자세히 나와있다.

#### addAndGet() 테스트 보완
add()에 대한 검증과 get()에 대한 검증 모두 보완할 필요가 있다. 또한, id를 조건으로 해서 사용자를 검색하는 기능을 가진 get()에 대한 테스트도 필요하다. 아래와 같이 코드를 작성함으로써 get()메소드에 대한 검증여부에 대해 좀 더 확신할 수 있게 됐다.
```java
@Test
public void addAndGet() throws SQLException {
    ApplicationContext context = new ClassPathXmlApplicationContext("applicaionContext.xml");
    
    UserDao dao = context.getBean("userDao", UserDao.class);
    User user1 = new User("young1", "김영재", "spring1");
    User user1 = new User("young2", "김영철", "spring2");
    
    //모든 데이터를 삭제하고 이를 검증하기 위해 추가되었다.
    dao.deleteAll();
    assertThat(dao.getCount(), is(0));
    
    //DB에 데이터가 add되는것에 대한 검증부분이다.
    dao.add(user1);
    dao.add(user2);
    assertThat(dao.getCount(), is(2));
    
    //user1 오브젝트와 get()으로 가져온 userget1을 검증한다.
    User userget1 = dao.get(user1.getId());
    assertThat(userget1.getName(), is(user1.getName()));
    assertThat(userget1.getPassword(), is(user1.getPassword()));
    
    //user2 오브젝트와 get()으로 가져온 userget2을 검증한다.
    User userget2 = dao.get(user2.getId());
    assertThat(userget2.getName(), is(user2.getName()));
    assertThat(userget2.getPassword(), is(user2.getPassword()));
}
```
#### get() 예외조건에 대한 테스트
get() 메소드에 전달된 id값에 해당하는 정보가 없으면 어떻게 할까? 하나는 null과 같은 특별한 값을 리턴하는 것이고, 다른 하나는 정보를 찾을 수 없다는 예외를 던지는 것이다. 각각의 장단점이 있지만 후자를 택해서 진행해 보자. 
스프링이 정의 한 다양한 데이터 액세스 예외 클래스중 EmptyResultDataAccessException 예외를 이용하자.
```java
@Test(exptected=EmptyResultDataAccessException.class) //테스트중 발생할 것으로 기대되는 예외 클래스 지정
public void addAndGet() throws SQLException {
    ApplicationContext context = new ClassPathXmlApplicationContext("applicaionContext.xml");
    
    UserDao dao = context.getBean("userDao", UserDao.class);
    User user1 = new User("young1", "김영재", "spring1");
    User user1 = new User("young2", "김영철", "spring2");
    
    //모든 데이터를 삭제하고 이를 검증하기 위해 추가되었다.
    dao.deleteAll();
    assertThat(dao.getCount(), is(0));
}
```
- 위의 코드는 이전과는 반대로 expected에서 지정한 예외가 던져지면 성공이고, 정상적으로 테스트 메소드를 마치면 실패라고 뜬다.
- 예외가 반드시 발생해야 하는 경우에 유용하다.