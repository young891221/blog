## AOP란 무엇인가?
이제까지 UserService에 트랜잭션을 적용해 온 과정을 되짚어 보자.

### 1. 트랜잭션 서비스 추상화
트랜잭션 적용을 비즈니스 로직과 함께 넣었을 때 문제가 발생한다. 트랜잭션을 제외한 부분에서 수정작업이 있더라도 트랜잭션 적용 코드를 수정해야 하는 심각한 문제가 있었다. 
그래서 인터페이스와 DI를 통해 무엇을 하는지를 남기고 분리하는 트랜잭션 추상화를 수행하였다. 트랜잭션 적용은 더 이상 비즈니스 로직 코드에는 영향을 주지 않고 독립적으로 변경할 수 있게 되었다.

### 2. 프록시와 데코레이션 패턴
여전히 비즈니스 로직에는 트랜잭션을 어디에 적용할지 경계설정을 담당하는 코드가 남아 있었다. 이를 제거하기 위해 **DI를 이용한 데코레이터 패턴을 적용**하였다. 클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고 
데코레이터 패턴을 적용해서, 트랜잭션 부가기능을 자유롭게 적용할 수 있게 되었다. 그래서 클라이언트가 일종의 대리자인 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근할 수 있게 됐다.
 
### 3. 다이내믹 프록시와 프록시 팩토리 빈
데코레이션 패턴의 결과 비즈니스 로직에서 트랜잭션 코드는 모두 제거하였지만. 비즈니스 로직 인터페이스에 모두 트랜잭션을 부여받아 프록시 클래스를 만드는 작업은 큰 단점으로 남았다. 모든 코드에 일일이 다 구현해야 했다. 
그래서 다이내믹 프록시 기술을 적용하여 부가기능 코드의 중복을 해결하고 메소드 선정 패턴을 이용할 수 있었다. 하지만 프록시를 여러 프로젝트에 적용할 경우 오브젝트 단위로는 중복이 일어났다. 그래서 다이내믹 프록시와 같은 프록시 기술을 
추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성 방법에 DI를 도입했다. 내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와 포인트컷은 프록시에서 분리될 수 있었고 
여러 프록시에서 공유해서 사용할 수 있었다.

### 4. 자동 프록시 생성 방법과 포인트컷
트랜잭션 적용 대상마다 일일이 프록시 팩토리 빈을 설정해야 하는 부담이 있었다. 이를 위해 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다. 
포인트컷도 완전히 분리하였고 최종적으로 포인트컷 표현식을 써서 좀 더 편리하고 깔끔하게 설정할 수 있었다.

### 5. 부가기능의 모듈화
지금까지의 DI, 데코레이터 패턴, 다이내믹 프록시, 오브젝트 생성 후처리, 자동 프록시 생성, 포인트컷은 여기저기 흩어져 있는 트랜잭션 기능을 독립적인 모듈로 만들기 위한 방법이었다. 덕분에 TransactionAdvice라는 이름으로 
모듈화하여 코드가 중복되지 않고 변경이 필요한 한 곳만 수정하면 되었다. 결국 핵심은 **모듈화**였다.

### 6. AOP: 애스펙트 지향 프로그래밍
부가기능을 어떻게 모듈화할 것인가를 연구한 사람들은 이 모듈화 작업이 기존의 객체지향 설계 패러다임과는 구분되는 새로운 특성이 있다고 생각했다. 그래서 새롭게 탄생한 이름이 **애스펙트(aspect)**이다. 
- 애스팩트란 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만, 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다.
- 애스팩트는 부가될 기능을 정의한 코드인 어드바이스와 정의 범위를 지정하는 포인트컷을 함께 갖고 있다.
- 우리가 사용한 어드바이저는 아주 단순한 형태의 애스팩트라 볼 수 있다.
- 2차원적인 평면구조가 아닌, 3차원의 다면체 구조로 가져가면서 각각 성격이 다른 부가기능은 다른 면에 존재하도록 만들었다. 이를 **애스펙트 지향 프로그래밍(AOP)라 한다.**

### AOP 적용기술
스프링의 AOP는 **우리가 사용했던 기법들을 활용한 프록시 방식의 AOP**와 **AspectJ를 사용하여 프록시를 쓰지 않는 AOP 기술**이 있다. 그렇다면 어떻게 프록시 없이 부가기능을 타깃 오브젝트에 적용해 줄 수 있을까? 
AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용한다. 컴파일된 타깃의 클래스 파일 자체를  JVM에 로딩되는 시점을 가로채서 바이트코드로 조작하는 복잡한 
방법을 사용한다. 즉, 트랜잭션 코드가 비즈니스 로직과 함께 있었을 때처럼 만들어버린다. 왜 프록시를 사용하지 않고 이러한 방법을 사용할까?
- 1)바이트코드를 조작해 타깃 오브젝트를 직접 수정해버리면 DI 컨테이너의 도움을 받아 프록시를 생성하지 않고 AOP를 적용할 수 있기 때문이다.
- 2)프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문이다.
	- 프록시를 사용하면 대상이 메소드로 제한되지만 바이트코드를 직접 조작하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 부가기능을 수행할 수 있다.
	- 타깃 오브젝트가 생성되는 순간에도 작업이 가능하다.

>AspectJ같은 고급 기술을 사용하기 위해 별도의 바이트코드 컴파일러, 클래스 로더를 사용해야 하는 번거로움이 필요하다. 따라서 대부분은 프록시 방식의 스프링 AOP로도 충분하다.

### AOP 용어
- **타깃**: 부가기능을 부여할 대상, 경우에 따라 프록시 오브젝트일 수도 있다.
- **어드바이스**: 타깃에게 제공할 부가기능을 담은 모듈
	- MethodInterceptor처럼 메소드 호출 과정에 전반적으로 참여하는 것도 있고 예외가 발생했을 때만 동작하는 어드바이스도 있다.
- **조인 포인트**: 어드바이스가 적용될 수 있는 위치. 프록시 AOP에서는 메소드의 실행 단계분이다.
- **포인트컷**: 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈을 말한다.
	- 스프링 AOP의 조인 포인트는 메소드의 실행이므로 포인트컷은 메소드 선정기능을 같는다.
	- 그래서 포인트컷 표현식은 메소드의 실행의 의미인 execution으로 시작한다.
	- 메소드 선정이란 클래스를 선정하고 그 안의 메소드를 선정하는 과정이다.
- **프록시**: 클라이언트와 타깃 사이의 부가기능을 제공하는 오브젝트이다.
	- DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메소드 호출을 대신 받아서 타깃에 위임해 준다. 그 과정에서 부가기능을 수행한다.
- **어드바이저**: 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트이다. AOP의 가장 기본이 되는 모듈.
- **애스펙트**: 애스팩트는 AOP의 기본 모듈이다.
	- 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들며 보통 싱글톤 형태의 오브젝트이다.
	- 모듈 정의와 오브젝트와 같은 실체의 구분이 없으며 모두 애스펙트라 불린다.
	- 스프링의 어드바이저는 아주 단순한 애스펙트라 볼 수 있다.
